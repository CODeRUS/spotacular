// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mercury.proto

#ifndef PROTOBUF_mercury_2eproto__INCLUDED
#define PROTOBUF_mercury_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace spotify {
namespace mercury {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mercury_2eproto();
void protobuf_AssignDesc_mercury_2eproto();
void protobuf_ShutdownFile_mercury_2eproto();

class MercuryMultiGetRequest;
class MercuryMultiGetReply;
class MercuryRequest;
class MercuryReply;
class UserField;

enum MercuryReply_CachePolicy {
  MercuryReply_CachePolicy_CACHE_NO = 1,
  MercuryReply_CachePolicy_CACHE_PRIVATE = 2,
  MercuryReply_CachePolicy_CACHE_PUBLIC = 3
};
bool MercuryReply_CachePolicy_IsValid(int value);
const MercuryReply_CachePolicy MercuryReply_CachePolicy_CachePolicy_MIN = MercuryReply_CachePolicy_CACHE_NO;
const MercuryReply_CachePolicy MercuryReply_CachePolicy_CachePolicy_MAX = MercuryReply_CachePolicy_CACHE_PUBLIC;
const int MercuryReply_CachePolicy_CachePolicy_ARRAYSIZE = MercuryReply_CachePolicy_CachePolicy_MAX + 1;

const ::google::protobuf::EnumDescriptor* MercuryReply_CachePolicy_descriptor();
inline const ::std::string& MercuryReply_CachePolicy_Name(MercuryReply_CachePolicy value) {
  return ::google::protobuf::internal::NameOfEnum(
    MercuryReply_CachePolicy_descriptor(), value);
}
inline bool MercuryReply_CachePolicy_Parse(
    const ::std::string& name, MercuryReply_CachePolicy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MercuryReply_CachePolicy>(
    MercuryReply_CachePolicy_descriptor(), name, value);
}
// ===================================================================

class MercuryMultiGetRequest : public ::google::protobuf::Message {
 public:
  MercuryMultiGetRequest();
  virtual ~MercuryMultiGetRequest();

  MercuryMultiGetRequest(const MercuryMultiGetRequest& from);

  inline MercuryMultiGetRequest& operator=(const MercuryMultiGetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MercuryMultiGetRequest& default_instance();

  void Swap(MercuryMultiGetRequest* other);

  // implements Message ----------------------------------------------

  MercuryMultiGetRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MercuryMultiGetRequest& from);
  void MergeFrom(const MercuryMultiGetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .spotify.mercury.proto.MercuryRequest request = 1;
  inline int request_size() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline const ::spotify::mercury::proto::MercuryRequest& request(int index) const;
  inline ::spotify::mercury::proto::MercuryRequest* mutable_request(int index);
  inline ::spotify::mercury::proto::MercuryRequest* add_request();
  inline const ::google::protobuf::RepeatedPtrField< ::spotify::mercury::proto::MercuryRequest >&
      request() const;
  inline ::google::protobuf::RepeatedPtrField< ::spotify::mercury::proto::MercuryRequest >*
      mutable_request();

  // @@protoc_insertion_point(class_scope:spotify.mercury.proto.MercuryMultiGetRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::spotify::mercury::proto::MercuryRequest > request_;
  friend void  protobuf_AddDesc_mercury_2eproto();
  friend void protobuf_AssignDesc_mercury_2eproto();
  friend void protobuf_ShutdownFile_mercury_2eproto();

  void InitAsDefaultInstance();
  static MercuryMultiGetRequest* default_instance_;
};
// -------------------------------------------------------------------

class MercuryMultiGetReply : public ::google::protobuf::Message {
 public:
  MercuryMultiGetReply();
  virtual ~MercuryMultiGetReply();

  MercuryMultiGetReply(const MercuryMultiGetReply& from);

  inline MercuryMultiGetReply& operator=(const MercuryMultiGetReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MercuryMultiGetReply& default_instance();

  void Swap(MercuryMultiGetReply* other);

  // implements Message ----------------------------------------------

  MercuryMultiGetReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MercuryMultiGetReply& from);
  void MergeFrom(const MercuryMultiGetReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .spotify.mercury.proto.MercuryReply reply = 1;
  inline int reply_size() const;
  inline void clear_reply();
  static const int kReplyFieldNumber = 1;
  inline const ::spotify::mercury::proto::MercuryReply& reply(int index) const;
  inline ::spotify::mercury::proto::MercuryReply* mutable_reply(int index);
  inline ::spotify::mercury::proto::MercuryReply* add_reply();
  inline const ::google::protobuf::RepeatedPtrField< ::spotify::mercury::proto::MercuryReply >&
      reply() const;
  inline ::google::protobuf::RepeatedPtrField< ::spotify::mercury::proto::MercuryReply >*
      mutable_reply();

  // @@protoc_insertion_point(class_scope:spotify.mercury.proto.MercuryMultiGetReply)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::spotify::mercury::proto::MercuryReply > reply_;
  friend void  protobuf_AddDesc_mercury_2eproto();
  friend void protobuf_AssignDesc_mercury_2eproto();
  friend void protobuf_ShutdownFile_mercury_2eproto();

  void InitAsDefaultInstance();
  static MercuryMultiGetReply* default_instance_;
};
// -------------------------------------------------------------------

class MercuryRequest : public ::google::protobuf::Message {
 public:
  MercuryRequest();
  virtual ~MercuryRequest();

  MercuryRequest(const MercuryRequest& from);

  inline MercuryRequest& operator=(const MercuryRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MercuryRequest& default_instance();

  void Swap(MercuryRequest* other);

  // implements Message ----------------------------------------------

  MercuryRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MercuryRequest& from);
  void MergeFrom(const MercuryRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string uri = 1;
  inline bool has_uri() const;
  inline void clear_uri();
  static const int kUriFieldNumber = 1;
  inline const ::std::string& uri() const;
  inline void set_uri(const ::std::string& value);
  inline void set_uri(const char* value);
  inline void set_uri(const char* value, size_t size);
  inline ::std::string* mutable_uri();
  inline ::std::string* release_uri();
  inline void set_allocated_uri(::std::string* uri);

  // optional string content_type = 2;
  inline bool has_content_type() const;
  inline void clear_content_type();
  static const int kContentTypeFieldNumber = 2;
  inline const ::std::string& content_type() const;
  inline void set_content_type(const ::std::string& value);
  inline void set_content_type(const char* value);
  inline void set_content_type(const char* value, size_t size);
  inline ::std::string* mutable_content_type();
  inline ::std::string* release_content_type();
  inline void set_allocated_content_type(::std::string* content_type);

  // optional string method = 3;
  inline bool has_method() const;
  inline void clear_method();
  static const int kMethodFieldNumber = 3;
  inline const ::std::string& method() const;
  inline void set_method(const ::std::string& value);
  inline void set_method(const char* value);
  inline void set_method(const char* value, size_t size);
  inline ::std::string* mutable_method();
  inline ::std::string* release_method();
  inline void set_allocated_method(::std::string* method);

  // optional sint32 status_code = 4;
  inline bool has_status_code() const;
  inline void clear_status_code();
  static const int kStatusCodeFieldNumber = 4;
  inline ::google::protobuf::int32 status_code() const;
  inline void set_status_code(::google::protobuf::int32 value);

  // optional string source = 5;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 5;
  inline const ::std::string& source() const;
  inline void set_source(const ::std::string& value);
  inline void set_source(const char* value);
  inline void set_source(const char* value, size_t size);
  inline ::std::string* mutable_source();
  inline ::std::string* release_source();
  inline void set_allocated_source(::std::string* source);

  // repeated .spotify.mercury.proto.UserField user_fields = 6;
  inline int user_fields_size() const;
  inline void clear_user_fields();
  static const int kUserFieldsFieldNumber = 6;
  inline const ::spotify::mercury::proto::UserField& user_fields(int index) const;
  inline ::spotify::mercury::proto::UserField* mutable_user_fields(int index);
  inline ::spotify::mercury::proto::UserField* add_user_fields();
  inline const ::google::protobuf::RepeatedPtrField< ::spotify::mercury::proto::UserField >&
      user_fields() const;
  inline ::google::protobuf::RepeatedPtrField< ::spotify::mercury::proto::UserField >*
      mutable_user_fields();

  // @@protoc_insertion_point(class_scope:spotify.mercury.proto.MercuryRequest)
 private:
  inline void set_has_uri();
  inline void clear_has_uri();
  inline void set_has_content_type();
  inline void clear_has_content_type();
  inline void set_has_method();
  inline void clear_has_method();
  inline void set_has_status_code();
  inline void clear_has_status_code();
  inline void set_has_source();
  inline void clear_has_source();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* uri_;
  ::std::string* content_type_;
  ::std::string* method_;
  ::std::string* source_;
  ::google::protobuf::RepeatedPtrField< ::spotify::mercury::proto::UserField > user_fields_;
  ::google::protobuf::int32 status_code_;
  friend void  protobuf_AddDesc_mercury_2eproto();
  friend void protobuf_AssignDesc_mercury_2eproto();
  friend void protobuf_ShutdownFile_mercury_2eproto();

  void InitAsDefaultInstance();
  static MercuryRequest* default_instance_;
};
// -------------------------------------------------------------------

class MercuryReply : public ::google::protobuf::Message {
 public:
  MercuryReply();
  virtual ~MercuryReply();

  MercuryReply(const MercuryReply& from);

  inline MercuryReply& operator=(const MercuryReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MercuryReply& default_instance();

  void Swap(MercuryReply* other);

  // implements Message ----------------------------------------------

  MercuryReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MercuryReply& from);
  void MergeFrom(const MercuryReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MercuryReply_CachePolicy CachePolicy;
  static const CachePolicy CACHE_NO = MercuryReply_CachePolicy_CACHE_NO;
  static const CachePolicy CACHE_PRIVATE = MercuryReply_CachePolicy_CACHE_PRIVATE;
  static const CachePolicy CACHE_PUBLIC = MercuryReply_CachePolicy_CACHE_PUBLIC;
  static inline bool CachePolicy_IsValid(int value) {
    return MercuryReply_CachePolicy_IsValid(value);
  }
  static const CachePolicy CachePolicy_MIN =
    MercuryReply_CachePolicy_CachePolicy_MIN;
  static const CachePolicy CachePolicy_MAX =
    MercuryReply_CachePolicy_CachePolicy_MAX;
  static const int CachePolicy_ARRAYSIZE =
    MercuryReply_CachePolicy_CachePolicy_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CachePolicy_descriptor() {
    return MercuryReply_CachePolicy_descriptor();
  }
  static inline const ::std::string& CachePolicy_Name(CachePolicy value) {
    return MercuryReply_CachePolicy_Name(value);
  }
  static inline bool CachePolicy_Parse(const ::std::string& name,
      CachePolicy* value) {
    return MercuryReply_CachePolicy_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional sint32 status_code = 1;
  inline bool has_status_code() const;
  inline void clear_status_code();
  static const int kStatusCodeFieldNumber = 1;
  inline ::google::protobuf::int32 status_code() const;
  inline void set_status_code(::google::protobuf::int32 value);

  // optional string status_message = 2;
  inline bool has_status_message() const;
  inline void clear_status_message();
  static const int kStatusMessageFieldNumber = 2;
  inline const ::std::string& status_message() const;
  inline void set_status_message(const ::std::string& value);
  inline void set_status_message(const char* value);
  inline void set_status_message(const char* value, size_t size);
  inline ::std::string* mutable_status_message();
  inline ::std::string* release_status_message();
  inline void set_allocated_status_message(::std::string* status_message);

  // optional .spotify.mercury.proto.MercuryReply.CachePolicy cache_policy = 3;
  inline bool has_cache_policy() const;
  inline void clear_cache_policy();
  static const int kCachePolicyFieldNumber = 3;
  inline ::spotify::mercury::proto::MercuryReply_CachePolicy cache_policy() const;
  inline void set_cache_policy(::spotify::mercury::proto::MercuryReply_CachePolicy value);

  // optional sint32 ttl = 4;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 4;
  inline ::google::protobuf::int32 ttl() const;
  inline void set_ttl(::google::protobuf::int32 value);

  // optional bytes etag = 5;
  inline bool has_etag() const;
  inline void clear_etag();
  static const int kEtagFieldNumber = 5;
  inline const ::std::string& etag() const;
  inline void set_etag(const ::std::string& value);
  inline void set_etag(const char* value);
  inline void set_etag(const void* value, size_t size);
  inline ::std::string* mutable_etag();
  inline ::std::string* release_etag();
  inline void set_allocated_etag(::std::string* etag);

  // optional bytes content_type = 6;
  inline bool has_content_type() const;
  inline void clear_content_type();
  static const int kContentTypeFieldNumber = 6;
  inline const ::std::string& content_type() const;
  inline void set_content_type(const ::std::string& value);
  inline void set_content_type(const char* value);
  inline void set_content_type(const void* value, size_t size);
  inline ::std::string* mutable_content_type();
  inline ::std::string* release_content_type();
  inline void set_allocated_content_type(::std::string* content_type);

  // optional bytes body = 7;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 7;
  inline const ::std::string& body() const;
  inline void set_body(const ::std::string& value);
  inline void set_body(const char* value);
  inline void set_body(const void* value, size_t size);
  inline ::std::string* mutable_body();
  inline ::std::string* release_body();
  inline void set_allocated_body(::std::string* body);

  // @@protoc_insertion_point(class_scope:spotify.mercury.proto.MercuryReply)
 private:
  inline void set_has_status_code();
  inline void clear_has_status_code();
  inline void set_has_status_message();
  inline void clear_has_status_message();
  inline void set_has_cache_policy();
  inline void clear_has_cache_policy();
  inline void set_has_ttl();
  inline void clear_has_ttl();
  inline void set_has_etag();
  inline void clear_has_etag();
  inline void set_has_content_type();
  inline void clear_has_content_type();
  inline void set_has_body();
  inline void clear_has_body();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* status_message_;
  ::google::protobuf::int32 status_code_;
  int cache_policy_;
  ::std::string* etag_;
  ::std::string* content_type_;
  ::std::string* body_;
  ::google::protobuf::int32 ttl_;
  friend void  protobuf_AddDesc_mercury_2eproto();
  friend void protobuf_AssignDesc_mercury_2eproto();
  friend void protobuf_ShutdownFile_mercury_2eproto();

  void InitAsDefaultInstance();
  static MercuryReply* default_instance_;
};
// -------------------------------------------------------------------

class UserField : public ::google::protobuf::Message {
 public:
  UserField();
  virtual ~UserField();

  UserField(const UserField& from);

  inline UserField& operator=(const UserField& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserField& default_instance();

  void Swap(UserField* other);

  // implements Message ----------------------------------------------

  UserField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserField& from);
  void MergeFrom(const UserField& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:spotify.mercury.proto.UserField)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_mercury_2eproto();
  friend void protobuf_AssignDesc_mercury_2eproto();
  friend void protobuf_ShutdownFile_mercury_2eproto();

  void InitAsDefaultInstance();
  static UserField* default_instance_;
};
// ===================================================================


// ===================================================================

// MercuryMultiGetRequest

// repeated .spotify.mercury.proto.MercuryRequest request = 1;
inline int MercuryMultiGetRequest::request_size() const {
  return request_.size();
}
inline void MercuryMultiGetRequest::clear_request() {
  request_.Clear();
}
inline const ::spotify::mercury::proto::MercuryRequest& MercuryMultiGetRequest::request(int index) const {
  // @@protoc_insertion_point(field_get:spotify.mercury.proto.MercuryMultiGetRequest.request)
  return request_.Get(index);
}
inline ::spotify::mercury::proto::MercuryRequest* MercuryMultiGetRequest::mutable_request(int index) {
  // @@protoc_insertion_point(field_mutable:spotify.mercury.proto.MercuryMultiGetRequest.request)
  return request_.Mutable(index);
}
inline ::spotify::mercury::proto::MercuryRequest* MercuryMultiGetRequest::add_request() {
  // @@protoc_insertion_point(field_add:spotify.mercury.proto.MercuryMultiGetRequest.request)
  return request_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::spotify::mercury::proto::MercuryRequest >&
MercuryMultiGetRequest::request() const {
  // @@protoc_insertion_point(field_list:spotify.mercury.proto.MercuryMultiGetRequest.request)
  return request_;
}
inline ::google::protobuf::RepeatedPtrField< ::spotify::mercury::proto::MercuryRequest >*
MercuryMultiGetRequest::mutable_request() {
  // @@protoc_insertion_point(field_mutable_list:spotify.mercury.proto.MercuryMultiGetRequest.request)
  return &request_;
}

// -------------------------------------------------------------------

// MercuryMultiGetReply

// repeated .spotify.mercury.proto.MercuryReply reply = 1;
inline int MercuryMultiGetReply::reply_size() const {
  return reply_.size();
}
inline void MercuryMultiGetReply::clear_reply() {
  reply_.Clear();
}
inline const ::spotify::mercury::proto::MercuryReply& MercuryMultiGetReply::reply(int index) const {
  // @@protoc_insertion_point(field_get:spotify.mercury.proto.MercuryMultiGetReply.reply)
  return reply_.Get(index);
}
inline ::spotify::mercury::proto::MercuryReply* MercuryMultiGetReply::mutable_reply(int index) {
  // @@protoc_insertion_point(field_mutable:spotify.mercury.proto.MercuryMultiGetReply.reply)
  return reply_.Mutable(index);
}
inline ::spotify::mercury::proto::MercuryReply* MercuryMultiGetReply::add_reply() {
  // @@protoc_insertion_point(field_add:spotify.mercury.proto.MercuryMultiGetReply.reply)
  return reply_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::spotify::mercury::proto::MercuryReply >&
MercuryMultiGetReply::reply() const {
  // @@protoc_insertion_point(field_list:spotify.mercury.proto.MercuryMultiGetReply.reply)
  return reply_;
}
inline ::google::protobuf::RepeatedPtrField< ::spotify::mercury::proto::MercuryReply >*
MercuryMultiGetReply::mutable_reply() {
  // @@protoc_insertion_point(field_mutable_list:spotify.mercury.proto.MercuryMultiGetReply.reply)
  return &reply_;
}

// -------------------------------------------------------------------

// MercuryRequest

// optional string uri = 1;
inline bool MercuryRequest::has_uri() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MercuryRequest::set_has_uri() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MercuryRequest::clear_has_uri() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MercuryRequest::clear_uri() {
  if (uri_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_->clear();
  }
  clear_has_uri();
}
inline const ::std::string& MercuryRequest::uri() const {
  // @@protoc_insertion_point(field_get:spotify.mercury.proto.MercuryRequest.uri)
  return *uri_;
}
inline void MercuryRequest::set_uri(const ::std::string& value) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
  // @@protoc_insertion_point(field_set:spotify.mercury.proto.MercuryRequest.uri)
}
inline void MercuryRequest::set_uri(const char* value) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_ = new ::std::string;
  }
  uri_->assign(value);
  // @@protoc_insertion_point(field_set_char:spotify.mercury.proto.MercuryRequest.uri)
}
inline void MercuryRequest::set_uri(const char* value, size_t size) {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_ = new ::std::string;
  }
  uri_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:spotify.mercury.proto.MercuryRequest.uri)
}
inline ::std::string* MercuryRequest::mutable_uri() {
  set_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uri_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:spotify.mercury.proto.MercuryRequest.uri)
  return uri_;
}
inline ::std::string* MercuryRequest::release_uri() {
  clear_has_uri();
  if (uri_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = uri_;
    uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MercuryRequest::set_allocated_uri(::std::string* uri) {
  if (uri_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uri_;
  }
  if (uri) {
    set_has_uri();
    uri_ = uri;
  } else {
    clear_has_uri();
    uri_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:spotify.mercury.proto.MercuryRequest.uri)
}

// optional string content_type = 2;
inline bool MercuryRequest::has_content_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MercuryRequest::set_has_content_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MercuryRequest::clear_has_content_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MercuryRequest::clear_content_type() {
  if (content_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_->clear();
  }
  clear_has_content_type();
}
inline const ::std::string& MercuryRequest::content_type() const {
  // @@protoc_insertion_point(field_get:spotify.mercury.proto.MercuryRequest.content_type)
  return *content_type_;
}
inline void MercuryRequest::set_content_type(const ::std::string& value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
  // @@protoc_insertion_point(field_set:spotify.mercury.proto.MercuryRequest.content_type)
}
inline void MercuryRequest::set_content_type(const char* value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:spotify.mercury.proto.MercuryRequest.content_type)
}
inline void MercuryRequest::set_content_type(const char* value, size_t size) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:spotify.mercury.proto.MercuryRequest.content_type)
}
inline ::std::string* MercuryRequest::mutable_content_type() {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:spotify.mercury.proto.MercuryRequest.content_type)
  return content_type_;
}
inline ::std::string* MercuryRequest::release_content_type() {
  clear_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_type_;
    content_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MercuryRequest::set_allocated_content_type(::std::string* content_type) {
  if (content_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_type_;
  }
  if (content_type) {
    set_has_content_type();
    content_type_ = content_type;
  } else {
    clear_has_content_type();
    content_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:spotify.mercury.proto.MercuryRequest.content_type)
}

// optional string method = 3;
inline bool MercuryRequest::has_method() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MercuryRequest::set_has_method() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MercuryRequest::clear_has_method() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MercuryRequest::clear_method() {
  if (method_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_->clear();
  }
  clear_has_method();
}
inline const ::std::string& MercuryRequest::method() const {
  // @@protoc_insertion_point(field_get:spotify.mercury.proto.MercuryRequest.method)
  return *method_;
}
inline void MercuryRequest::set_method(const ::std::string& value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_ = new ::std::string;
  }
  method_->assign(value);
  // @@protoc_insertion_point(field_set:spotify.mercury.proto.MercuryRequest.method)
}
inline void MercuryRequest::set_method(const char* value) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_ = new ::std::string;
  }
  method_->assign(value);
  // @@protoc_insertion_point(field_set_char:spotify.mercury.proto.MercuryRequest.method)
}
inline void MercuryRequest::set_method(const char* value, size_t size) {
  set_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_ = new ::std::string;
  }
  method_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:spotify.mercury.proto.MercuryRequest.method)
}
inline ::std::string* MercuryRequest::mutable_method() {
  set_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    method_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:spotify.mercury.proto.MercuryRequest.method)
  return method_;
}
inline ::std::string* MercuryRequest::release_method() {
  clear_has_method();
  if (method_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = method_;
    method_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MercuryRequest::set_allocated_method(::std::string* method) {
  if (method_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete method_;
  }
  if (method) {
    set_has_method();
    method_ = method;
  } else {
    clear_has_method();
    method_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:spotify.mercury.proto.MercuryRequest.method)
}

// optional sint32 status_code = 4;
inline bool MercuryRequest::has_status_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MercuryRequest::set_has_status_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MercuryRequest::clear_has_status_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MercuryRequest::clear_status_code() {
  status_code_ = 0;
  clear_has_status_code();
}
inline ::google::protobuf::int32 MercuryRequest::status_code() const {
  // @@protoc_insertion_point(field_get:spotify.mercury.proto.MercuryRequest.status_code)
  return status_code_;
}
inline void MercuryRequest::set_status_code(::google::protobuf::int32 value) {
  set_has_status_code();
  status_code_ = value;
  // @@protoc_insertion_point(field_set:spotify.mercury.proto.MercuryRequest.status_code)
}

// optional string source = 5;
inline bool MercuryRequest::has_source() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MercuryRequest::set_has_source() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MercuryRequest::clear_has_source() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MercuryRequest::clear_source() {
  if (source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_->clear();
  }
  clear_has_source();
}
inline const ::std::string& MercuryRequest::source() const {
  // @@protoc_insertion_point(field_get:spotify.mercury.proto.MercuryRequest.source)
  return *source_;
}
inline void MercuryRequest::set_source(const ::std::string& value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(value);
  // @@protoc_insertion_point(field_set:spotify.mercury.proto.MercuryRequest.source)
}
inline void MercuryRequest::set_source(const char* value) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(value);
  // @@protoc_insertion_point(field_set_char:spotify.mercury.proto.MercuryRequest.source)
}
inline void MercuryRequest::set_source(const char* value, size_t size) {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  source_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:spotify.mercury.proto.MercuryRequest.source)
}
inline ::std::string* MercuryRequest::mutable_source() {
  set_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:spotify.mercury.proto.MercuryRequest.source)
  return source_;
}
inline ::std::string* MercuryRequest::release_source() {
  clear_has_source();
  if (source_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = source_;
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MercuryRequest::set_allocated_source(::std::string* source) {
  if (source_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete source_;
  }
  if (source) {
    set_has_source();
    source_ = source;
  } else {
    clear_has_source();
    source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:spotify.mercury.proto.MercuryRequest.source)
}

// repeated .spotify.mercury.proto.UserField user_fields = 6;
inline int MercuryRequest::user_fields_size() const {
  return user_fields_.size();
}
inline void MercuryRequest::clear_user_fields() {
  user_fields_.Clear();
}
inline const ::spotify::mercury::proto::UserField& MercuryRequest::user_fields(int index) const {
  // @@protoc_insertion_point(field_get:spotify.mercury.proto.MercuryRequest.user_fields)
  return user_fields_.Get(index);
}
inline ::spotify::mercury::proto::UserField* MercuryRequest::mutable_user_fields(int index) {
  // @@protoc_insertion_point(field_mutable:spotify.mercury.proto.MercuryRequest.user_fields)
  return user_fields_.Mutable(index);
}
inline ::spotify::mercury::proto::UserField* MercuryRequest::add_user_fields() {
  // @@protoc_insertion_point(field_add:spotify.mercury.proto.MercuryRequest.user_fields)
  return user_fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::spotify::mercury::proto::UserField >&
MercuryRequest::user_fields() const {
  // @@protoc_insertion_point(field_list:spotify.mercury.proto.MercuryRequest.user_fields)
  return user_fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::spotify::mercury::proto::UserField >*
MercuryRequest::mutable_user_fields() {
  // @@protoc_insertion_point(field_mutable_list:spotify.mercury.proto.MercuryRequest.user_fields)
  return &user_fields_;
}

// -------------------------------------------------------------------

// MercuryReply

// optional sint32 status_code = 1;
inline bool MercuryReply::has_status_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MercuryReply::set_has_status_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MercuryReply::clear_has_status_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MercuryReply::clear_status_code() {
  status_code_ = 0;
  clear_has_status_code();
}
inline ::google::protobuf::int32 MercuryReply::status_code() const {
  // @@protoc_insertion_point(field_get:spotify.mercury.proto.MercuryReply.status_code)
  return status_code_;
}
inline void MercuryReply::set_status_code(::google::protobuf::int32 value) {
  set_has_status_code();
  status_code_ = value;
  // @@protoc_insertion_point(field_set:spotify.mercury.proto.MercuryReply.status_code)
}

// optional string status_message = 2;
inline bool MercuryReply::has_status_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MercuryReply::set_has_status_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MercuryReply::clear_has_status_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MercuryReply::clear_status_message() {
  if (status_message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_message_->clear();
  }
  clear_has_status_message();
}
inline const ::std::string& MercuryReply::status_message() const {
  // @@protoc_insertion_point(field_get:spotify.mercury.proto.MercuryReply.status_message)
  return *status_message_;
}
inline void MercuryReply::set_status_message(const ::std::string& value) {
  set_has_status_message();
  if (status_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_message_ = new ::std::string;
  }
  status_message_->assign(value);
  // @@protoc_insertion_point(field_set:spotify.mercury.proto.MercuryReply.status_message)
}
inline void MercuryReply::set_status_message(const char* value) {
  set_has_status_message();
  if (status_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_message_ = new ::std::string;
  }
  status_message_->assign(value);
  // @@protoc_insertion_point(field_set_char:spotify.mercury.proto.MercuryReply.status_message)
}
inline void MercuryReply::set_status_message(const char* value, size_t size) {
  set_has_status_message();
  if (status_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_message_ = new ::std::string;
  }
  status_message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:spotify.mercury.proto.MercuryReply.status_message)
}
inline ::std::string* MercuryReply::mutable_status_message() {
  set_has_status_message();
  if (status_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    status_message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:spotify.mercury.proto.MercuryReply.status_message)
  return status_message_;
}
inline ::std::string* MercuryReply::release_status_message() {
  clear_has_status_message();
  if (status_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = status_message_;
    status_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MercuryReply::set_allocated_status_message(::std::string* status_message) {
  if (status_message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete status_message_;
  }
  if (status_message) {
    set_has_status_message();
    status_message_ = status_message;
  } else {
    clear_has_status_message();
    status_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:spotify.mercury.proto.MercuryReply.status_message)
}

// optional .spotify.mercury.proto.MercuryReply.CachePolicy cache_policy = 3;
inline bool MercuryReply::has_cache_policy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MercuryReply::set_has_cache_policy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MercuryReply::clear_has_cache_policy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MercuryReply::clear_cache_policy() {
  cache_policy_ = 1;
  clear_has_cache_policy();
}
inline ::spotify::mercury::proto::MercuryReply_CachePolicy MercuryReply::cache_policy() const {
  // @@protoc_insertion_point(field_get:spotify.mercury.proto.MercuryReply.cache_policy)
  return static_cast< ::spotify::mercury::proto::MercuryReply_CachePolicy >(cache_policy_);
}
inline void MercuryReply::set_cache_policy(::spotify::mercury::proto::MercuryReply_CachePolicy value) {
  assert(::spotify::mercury::proto::MercuryReply_CachePolicy_IsValid(value));
  set_has_cache_policy();
  cache_policy_ = value;
  // @@protoc_insertion_point(field_set:spotify.mercury.proto.MercuryReply.cache_policy)
}

// optional sint32 ttl = 4;
inline bool MercuryReply::has_ttl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MercuryReply::set_has_ttl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MercuryReply::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MercuryReply::clear_ttl() {
  ttl_ = 0;
  clear_has_ttl();
}
inline ::google::protobuf::int32 MercuryReply::ttl() const {
  // @@protoc_insertion_point(field_get:spotify.mercury.proto.MercuryReply.ttl)
  return ttl_;
}
inline void MercuryReply::set_ttl(::google::protobuf::int32 value) {
  set_has_ttl();
  ttl_ = value;
  // @@protoc_insertion_point(field_set:spotify.mercury.proto.MercuryReply.ttl)
}

// optional bytes etag = 5;
inline bool MercuryReply::has_etag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MercuryReply::set_has_etag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MercuryReply::clear_has_etag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MercuryReply::clear_etag() {
  if (etag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    etag_->clear();
  }
  clear_has_etag();
}
inline const ::std::string& MercuryReply::etag() const {
  // @@protoc_insertion_point(field_get:spotify.mercury.proto.MercuryReply.etag)
  return *etag_;
}
inline void MercuryReply::set_etag(const ::std::string& value) {
  set_has_etag();
  if (etag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    etag_ = new ::std::string;
  }
  etag_->assign(value);
  // @@protoc_insertion_point(field_set:spotify.mercury.proto.MercuryReply.etag)
}
inline void MercuryReply::set_etag(const char* value) {
  set_has_etag();
  if (etag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    etag_ = new ::std::string;
  }
  etag_->assign(value);
  // @@protoc_insertion_point(field_set_char:spotify.mercury.proto.MercuryReply.etag)
}
inline void MercuryReply::set_etag(const void* value, size_t size) {
  set_has_etag();
  if (etag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    etag_ = new ::std::string;
  }
  etag_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:spotify.mercury.proto.MercuryReply.etag)
}
inline ::std::string* MercuryReply::mutable_etag() {
  set_has_etag();
  if (etag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    etag_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:spotify.mercury.proto.MercuryReply.etag)
  return etag_;
}
inline ::std::string* MercuryReply::release_etag() {
  clear_has_etag();
  if (etag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = etag_;
    etag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MercuryReply::set_allocated_etag(::std::string* etag) {
  if (etag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete etag_;
  }
  if (etag) {
    set_has_etag();
    etag_ = etag;
  } else {
    clear_has_etag();
    etag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:spotify.mercury.proto.MercuryReply.etag)
}

// optional bytes content_type = 6;
inline bool MercuryReply::has_content_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MercuryReply::set_has_content_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MercuryReply::clear_has_content_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MercuryReply::clear_content_type() {
  if (content_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_->clear();
  }
  clear_has_content_type();
}
inline const ::std::string& MercuryReply::content_type() const {
  // @@protoc_insertion_point(field_get:spotify.mercury.proto.MercuryReply.content_type)
  return *content_type_;
}
inline void MercuryReply::set_content_type(const ::std::string& value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
  // @@protoc_insertion_point(field_set:spotify.mercury.proto.MercuryReply.content_type)
}
inline void MercuryReply::set_content_type(const char* value) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:spotify.mercury.proto.MercuryReply.content_type)
}
inline void MercuryReply::set_content_type(const void* value, size_t size) {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  content_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:spotify.mercury.proto.MercuryReply.content_type)
}
inline ::std::string* MercuryReply::mutable_content_type() {
  set_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    content_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:spotify.mercury.proto.MercuryReply.content_type)
  return content_type_;
}
inline ::std::string* MercuryReply::release_content_type() {
  clear_has_content_type();
  if (content_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = content_type_;
    content_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MercuryReply::set_allocated_content_type(::std::string* content_type) {
  if (content_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete content_type_;
  }
  if (content_type) {
    set_has_content_type();
    content_type_ = content_type;
  } else {
    clear_has_content_type();
    content_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:spotify.mercury.proto.MercuryReply.content_type)
}

// optional bytes body = 7;
inline bool MercuryReply::has_body() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MercuryReply::set_has_body() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MercuryReply::clear_has_body() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MercuryReply::clear_body() {
  if (body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_->clear();
  }
  clear_has_body();
}
inline const ::std::string& MercuryReply::body() const {
  // @@protoc_insertion_point(field_get:spotify.mercury.proto.MercuryReply.body)
  return *body_;
}
inline void MercuryReply::set_body(const ::std::string& value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  body_->assign(value);
  // @@protoc_insertion_point(field_set:spotify.mercury.proto.MercuryReply.body)
}
inline void MercuryReply::set_body(const char* value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  body_->assign(value);
  // @@protoc_insertion_point(field_set_char:spotify.mercury.proto.MercuryReply.body)
}
inline void MercuryReply::set_body(const void* value, size_t size) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  body_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:spotify.mercury.proto.MercuryReply.body)
}
inline ::std::string* MercuryReply::mutable_body() {
  set_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    body_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:spotify.mercury.proto.MercuryReply.body)
  return body_;
}
inline ::std::string* MercuryReply::release_body() {
  clear_has_body();
  if (body_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = body_;
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MercuryReply::set_allocated_body(::std::string* body) {
  if (body_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete body_;
  }
  if (body) {
    set_has_body();
    body_ = body;
  } else {
    clear_has_body();
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:spotify.mercury.proto.MercuryReply.body)
}

// -------------------------------------------------------------------

// UserField

// optional string name = 1;
inline bool UserField::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserField::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserField::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserField::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UserField::name() const {
  // @@protoc_insertion_point(field_get:spotify.mercury.proto.UserField.name)
  return *name_;
}
inline void UserField::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:spotify.mercury.proto.UserField.name)
}
inline void UserField::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:spotify.mercury.proto.UserField.name)
}
inline void UserField::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:spotify.mercury.proto.UserField.name)
}
inline ::std::string* UserField::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:spotify.mercury.proto.UserField.name)
  return name_;
}
inline ::std::string* UserField::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserField::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:spotify.mercury.proto.UserField.name)
}

// optional bytes value = 2;
inline bool UserField::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserField::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserField::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserField::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& UserField::value() const {
  // @@protoc_insertion_point(field_get:spotify.mercury.proto.UserField.value)
  return *value_;
}
inline void UserField::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:spotify.mercury.proto.UserField.value)
}
inline void UserField::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:spotify.mercury.proto.UserField.value)
}
inline void UserField::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:spotify.mercury.proto.UserField.value)
}
inline ::std::string* UserField::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:spotify.mercury.proto.UserField.value)
  return value_;
}
inline ::std::string* UserField::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserField::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:spotify.mercury.proto.UserField.value)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace mercury
}  // namespace spotify

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::spotify::mercury::proto::MercuryReply_CachePolicy> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::spotify::mercury::proto::MercuryReply_CachePolicy>() {
  return ::spotify::mercury::proto::MercuryReply_CachePolicy_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mercury_2eproto__INCLUDED
